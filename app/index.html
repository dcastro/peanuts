<html>
<head>

    <title>Peanuts</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/deps/bootstrap/dist/css/bootstrap.css">
    <link rel="stylesheet" href="/deps/highlightjs/styles/darkula.css">
    <link rel="stylesheet" href="/assets/styles/styles.css">
    
    <script src="/assets/scripts/codePrinter.js"></script>

    <script src="/deps/papaparse/papaparse.js"></script>
    <script src="/deps/lodash/lodash.js"></script>
    <script src="/assets/geo/geo-data.js"></script>
    <script src="/coordinatesHelper.js"></script>
    <script src="/ironbarkService.js"></script>

    <script src="/deps/highlightjs/highlight.pack.min.js"></script>
    <script src="/deps/dat.gui/build/dat.gui.min.js"></script>
    <script src="/deps/stats-js/build/stats.min.js"></script>
    <script src="/deps/signals/dist/signals.min.js"></script>

    <script src="/deps/three/build/three.min.js"></script>
    <script src="/deps/three/examples/js/controls/OrbitControls.js"></script>


    <script src="/deps/three/examples/js/shaders/BleachBypassShader.js"></script>
    <script src="/deps/three/examples/js/shaders/ColorifyShader.js"></script>
    <script src="/deps/three/examples/js/shaders/ConvolutionShader.js"></script>
    <script src="/deps/three/examples/js/shaders/CopyShader.js"></script>
    <script src="/deps/three/examples/js/shaders/DotScreenShader.js"></script>
    <script src="/deps/three/examples/js/shaders/RGBShiftShader.js"></script>
    <script src="/deps/three/examples/js/shaders/SobelOperatorShader.js"></script>
    
    <script src="/deps/three/examples/js/shaders/FilmShader.js"></script>
    <script src="/deps/three/examples/js/shaders/HorizontalBlurShader.js"></script>
    <script src="/deps/three/examples/js/shaders/SepiaShader.js"></script>
    <script src="/deps/three/examples/js/shaders/VerticalBlurShader.js"></script>
    <script src="/deps/three/examples/js/shaders/VignetteShader.js"></script>
    <script src="/deps/three/examples/js/shaders/DigitalGlitch.js"></script>

    <script src="/deps/three/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="/deps/three/examples/js/postprocessing/RenderPass.js"></script>
    <script src="/deps/three/examples/js/postprocessing/BloomPass.js"></script>
    <script src="/deps/three/examples/js/postprocessing/GlitchPass.js"></script>
    
    <script src="/deps/three/examples/js/postprocessing/FilmPass.js"></script>
    <script src="/deps/three/examples/js/postprocessing/DotScreenPass.js"></script>
    <script src="/deps/three/examples/js/postprocessing/TexturePass.js"></script>
    <script src="/deps/three/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="/deps/three/examples/js/postprocessing/MaskPass.js"></script>



    <script src="/peanuts/peanuts.js"></script>
    <script src="/peanuts/peanuts.three.driver.js"></script>
    <script src="/peanuts/peanuts.three.inputs.js"></script>
    <script src="/peanuts/peanuts.three.loaders.js"></script>
    <script src="/peanuts/peanuts.three.assets.js"></script>
    <script src="/peanuts/peanuts.three.app.js"></script>
    <script src="/peanuts/peanuts.three.app.builder.js"></script>
    <script src="/peanuts/peanuts.three.app.factory.js"></script>
    <script src="/peanuts/peanuts.three.view.js"></script>
    <script src="/peanuts/peanuts.three.view.builder.js"></script>
    <script src="/peanuts/ui/peanuts.three.dat.gui.js"></script>
    <script src="/peanuts/ui/peanuts.three.dat.gui.geometry.js"></script>

    <style type="text/css">

        body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
        }

        .threeApp {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
        }
    </style>

</head>

    <body>


            <div id="app" class="threeApp"></div>

            <script type="text/javascript">


                function calcPosFromLatLonRad(lat, lng,radius){

                        var phi = (90 - lat) * Math.PI / 180;
                        var theta = (180 - lng) * Math.PI / 180;

                        var position = new THREE.Vector3(
                            radius * Math.sin(phi) * Math.cos(theta),
                            radius * Math.cos(phi),
                            radius * Math.sin(phi) * Math.sin(theta)
                        );

                        return position;
                    }

                    var setTexture = function(material, toSet) {
                        return function(texture) {
                            material[toSet] = texture;
                            material.needsUpdate = true;
                            texture.minFilter = THREE.LinearFilter;
                        };
                    };


                    var clock = new THREE.Clock();
                    var app = new Peanuts.Three.App.Factory(
                        document.getElementById("app")
                    ).createDemoGLPerspectiveApp();

                    var demoSettings =  {
                        data: {
                            glitch: 0,
                            hour: 0,
                            max: 1,
                            stoof: [],
                            cylinders: []
                        },
                        light : {
                            color :  new THREE.Color(0xFFFFFF),
                            position: new THREE.Vector3(-55,50,-60),
                            intensity : 0.8
                        }, 
                        overlay : {
                            geometry: {
                                radius : 1010,
                                widthSegments :64,
                                heightSegments : 64
                            },
                            material: {
                                opacity: 1,
                                wireframe : false,
                                shininess: 70,
                                color :  new THREE.Color(0x00FF00),
                                alphaMap:  "/textures/earth/earth-dark-alpha.png"
                            }
                        },
                        globe : {
                            geometry: {
                                radius : 1000,
                                widthSegments :256,
                                heightSegments : 256
                            },
                            material: {
                                opacity: 1,
                                wireframe : false,
                                shininess: 70,
                                color :  new THREE.Color(0xFFFFFF),
                                map: "/textures/earth/earth-dark-map.jpg",
                                bumpMap: "/textures/earth/earth-dark-bump.jpg"
                            }
                        }
                    };

                    function createGlobe(demoSettings) {

                        var sphereGeometry = new THREE.SphereGeometry(
                            demoSettings.globe.geometry.radius,
                            demoSettings.globe.geometry.widthSegments,
                            demoSettings.globe.geometry.heightSegments
                        );

                        var sphereMaterial = new THREE.MeshPhongMaterial({
                            color: new THREE.Color(demoSettings.globe.material.color),
                            wireframe: demoSettings.globe.material.wireframe,
                            opacity: demoSettings.globe.material.opacity
                        });

                        var sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);

                        app.loader.texture.load(demoSettings.globe.material.map).then(setTexture(sphereMaterial, "map"));
                        app.loader.texture.load(demoSettings.globe.material.bumpMap).then(setTexture(sphereMaterial, "bumpMap"));
                        app.loader.texture.load(demoSettings.globe.material.specularMap).then(setTexture(sphereMaterial, "specularMap"));

                        return sphereMesh;
                    }


                    function createCylinder(lat, lng, height, color, width) {
                        var cylinderGeometry = new THREE.CylinderGeometry(
                            3,
                            1,
                            height,
                            10,
                            1,
                            false,
                            0,
                            2 * Math.PI
                        );
                        var cylinderMaterial = new THREE.MeshBasicMaterial({
                            wireframe: false,
                            color: color
                        });
                        var cylinderMesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);

                        cylinderMesh.rotation.setFromVector3(
                            new THREE.Vector3(
                                THREE.Math.degToRad(0),
                                THREE.Math.degToRad(lng),
                                THREE.Math.degToRad(90-lat)
                            )
                        );

                        cylinderMesh.translateY(height/2);

                        return cylinderMesh;
                    }

                    function createLine(ep, color) {
                        var material = new THREE.LineBasicMaterial({
                            color: color,
                            lineWidth: 10,
                        });

                        var geometry = new THREE.Geometry();
                            geometry.vertices.push(
                                new THREE.Vector3( 0, 0, 0 ),
                                new THREE.Vector3( ep.x, ep.y, ep.z )
                            );

                        var line = new THREE.Line( geometry, material );
                   
                        return line;
                    }

                    function createGlobeOverlay(demoSettings) {

                        var sphereGeometry = new THREE.SphereGeometry(
                            demoSettings.overlay.geometry.radius,
                            demoSettings.overlay.geometry.widthSegments,
                            demoSettings.overlay.geometry.heightSegments
                        );

                        var sphereMaterial = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(demoSettings.overlay.material.color),
                            wireframe: demoSettings.overlay.material.wireframe,
                            opacity: demoSettings.overlay.material.opacity
                        });

                        var sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);

             

                        //app.loader.texture.load(demoSettings.overlay.material.alphaMap).then(setTexture(sphereMaterial, "map"));
                        app.loader.texture.load(demoSettings.overlay.material.alphaMap).then(setTexture(sphereMaterial, "alphaMap"));

                        return sphereMesh;
                    }


                    function createPostProcessing(demoSettings) {

                        // postprocessing
                        var composer = new THREE.EffectComposer(app.renderer);
                         
                        var dotscreen = new THREE.ShaderPass(THREE.DotScreenShader);
                            dotscreen.uniforms['scale'].value = 40;
                            dotscreen.renderToScreen = true;

                        var effectFilmBW = new THREE.FilmPass( 0.95, 2, 2048);
                          //  effectFilmBW.renderToScreen = true;

                        var rgbshift = new THREE.ShaderPass(THREE.RGBShiftShader);
                            rgbshift.uniforms['amount'].value = 0.0015;
                            //rgbshift.renderToScreen = true;

                        var glitch = new THREE.GlitchPass(demoSettings.data.glitch);
                            glitch.renderToScreen = true;

                        // var sobel_pass = new THREE.ShaderPass(THREE.SobelOperatorShader);
                        //     sobel_pass.uniforms.resolution.value = new THREE.Vector2(1900, 1200); //or whatever resolution your screen is
                        //     sobel_pass.renderToScreen = true;
                        
                         composer.addPass(new THREE.RenderPass(app.view.scene, app.view.camera));
                         composer.addPass(effectFilmBW);
                         composer.addPass(rgbshift);
                         composer.addPass(glitch);
                        // composer.addPass(sobel_pass);
 
                         app.view.setComposer(composer);
                    }

                    function modelDataAsCylinders(data, max, hour){
                        let cylinders = [];

                        data[hour].map((item) => {
                            const normalizedValue = 1000 + (item.calls / max) * 1000;
                            const color = Math.round((item.calls / max) * 255)
                            const colorRgb = new THREE.Color(`rgb(${color},${255 - color},0)`)
                            cylinders.push(
                                createCylinder(item.lat, item.lng, normalizedValue, colorRgb)
                            );

                        })
                        return cylinders;
                    }

                    function createControls(demoSettings) {
                        app.datGui.add(demoSettings.data, "glitch", 0, 1000);
                        app.datGui.add(demoSettings.data, "hour", 0, 23)
                            .onChange(x => {

                                demoSettings.data.cylinders.map(c => app.view.scene.remove(c))
                                demoSettings.data.cylinders = modelDataAsCylinders(demoSettings.data.stoof, demoSettings.data.max, x)
                                demoSettings.data.cylinders.map(c =>
                                    app.view.scene.add(c)
                                );

                            })
                            .step(1)
                    }

                    function createLight(demoSettings) {
                        var ambientLight = new THREE.AmbientLight(0x444444);
                        app.view.scene.add(ambientLight);

                        var lightDirectional = new THREE.DirectionalLight(
                            demoSettings.light.color,
                            demoSettings.light.intensity
                        );
                        app.view.scene.add(lightDirectional);

                        var pointLights = [];
                        pointLights[0] = new THREE.PointLight( 0xff0000, 2, 5000 );
                        pointLights[1] = new THREE.PointLight( 0x00ff00, 2, 5000 );
                        pointLights[2] = new THREE.PointLight( 0x0000ff, 2, 5000 );
                        pointLights[3] = new THREE.PointLight( 0xff0000, 5, 3000 );
                        pointLights[4] = new THREE.PointLight( 0x00ff00, 5, 3000 );
                        pointLights[5] = new THREE.PointLight( 0x0000ff, 5, 3000 );
                        for ( var i = 0, il = pointLights.length; i < il; i ++ ) {
                            app.view.scene.add( pointLights[i] );
                        }

                        return {ambientLight, lightDirectional, pointLights}
                    }

                    function createScene(demoSettings) {
                        app.view.camera.position.set(0,0, -2400);
                        app.view.controls.update();

                        var globe = createGlobe(demoSettings);
                        var globeOverlay = createGlobeOverlay(demoSettings);

                        app.view.setScene(new THREE.Scene());

                        app.view.scene.background = new THREE.Color(0,0x000000);
                        app.view.scene.add(app.view.camera);
               
                        //app.view.scene.add(globeOverlay);

                        //createPostProcessing(demoSettings);
                        createControls(demoSettings);
                        const {lightDirectional, pointLights, ...rest} = createLight(demoSettings);

                        var ironbarkService = new IronbarkService();

                        const coordsHelper = new CoordinatesHelper();

                        ironbarkService.topN("calls", "2018-12-16", "2018-12-17", "hour").then(
                            (data) => data.map( (item) => coordsHelper.addLatLng(item.result)),
                            ex => console.log(ex)
                        ).then( (data) => {
                            app.view.scene.add(globe);

                            demoSettings.data.stoof = data.map(x => {
                                x.splice(0,2)
                                return x;
                            })

                            demoSettings.data.max = _.maxBy(demoSettings.data.stoof.map(x=>x[0]), 'calls').calls;

                            demoSettings.data.cylinders = modelDataAsCylinders(demoSettings.data.stoof, demoSettings.data.max, demoSettings.data.hour)
                            demoSettings.data.cylinders.map(c =>
                                app.view.scene.add(c)
                            );

                        });

                        return {
                            camera : app.view.camera,
                            light : lightDirectional,
                            pointLights,
                            globe,
                        };
                    }



                    var demoObjects = createScene(demoSettings);

                    app.view.onUpdate( function() {

                        let rot  =  new THREE.Vector3(
                            THREE.Math.degToRad(0),
                            THREE.Math.degToRad(180),
                            THREE.Math.degToRad(0)
                        );



                        demoObjects.globe.rotation.setFromVector3(rot);

                        //demoObjects.light.position.set(new THREE.Vector3(-55,50,-60));
                        demoObjects.light.position.copy( demoObjects.camera.position );


                        var delta = clock.getDelta();
                        var time = Date.now() * 0.0004;

                        for ( var i = 1, il = demoObjects.pointLights.length; i <= il; i ++ ) {
                            demoObjects.pointLights[i-1].position.set(
                                3000 * Math.sin(time + i) * Math.cos(i),
                                3000 * Math.cos(time + i),
                                3000 * Math.sin(time + i) * Math.sin(i)
                            );
                        }
                    });

                    app.start();

            </script>
 
    </body>
</html>